
#include "sha1.h"

//unsigned long Message_Digest[5];
//unsigned long M[16];


/*******************************************
 *  左循环移位
 *******************************************/
unsigned long SHA1CircularShift(unsigned char bits,unsigned long word)  
{
	return ((word) << (bits))|((word) >> (32-(bits)));
}
/*************************************
常数K
*************************************/
unsigned long Kt(unsigned char t)                                       //Kt 
{ 
	if(t==0)return(0x5A827999); 
	else if(t==1)return(0x6ED9EBA1);  
	else if(t==2)return(0x8F1BBCDC);   
	else return(0xCA62C1D6); 	
}
/*************************************
ft函数
*************************************/
unsigned long ft(unsigned long b,unsigned long c,unsigned long d,unsigned char t)               //ft(B,C,D) 
{  
	if(t==0) return((b&c)|((~b)&d)); 
	else if((t==1)||(t==3)) return(b^c^d);                 
	else return((b&c)|(b&d)|(c&d));    	
}
/*************************************
Wt序列计算
*************************************/
unsigned long Wt(unsigned char t,unsigned long* M)                                       //Wt 
{         
	unsigned long mm;
	unsigned char i;
	if(t>15) 
	{ 
		//if(t>31) t=t+16-t/16*16;
		//t=16;
		mm=SHA1CircularShift(1,M[13] ^ M[8] ^ M[2] ^ M[0]);
		for(i=0;i<15;i++)
                {
			M[i]=M[i+1];
		 }       
		M[15]=mm;
	} 
	else mm = M[t];
	return mm; 
}
/******************************************* 
 *  SHA1ProcessMessageBlock     
 *处理信息块
 *******************************************/
void SHA1ProcessMessageBlock(unsigned long *ABCDE,unsigned long *M)
{     
    unsigned char  t,i;                  
    unsigned long   temp;              
	
    ABCDE[0] = 0x67452301;
    ABCDE[1] = 0xEFCDAB89;
    ABCDE[2] = 0x98BADCFE;
    ABCDE[3] = 0x10325476;
    ABCDE[4] = 0xC3D2E1F0;
    

	for(t=0;t<4;t++)
	{
	   for(i=t*20;i<t*20+20;i++)                                    //count sha1 
	   {   
		 temp = SHA1CircularShift(5,ABCDE[0])+ft(ABCDE[1],ABCDE[2],ABCDE[3],t)+ABCDE[4]+Wt(i,M)+Kt(t); 
		 ABCDE[4] = ABCDE[3];
                 ABCDE[3] = ABCDE[2];
                 ABCDE[2] = SHA1CircularShift(30,ABCDE[1]);
                 ABCDE[1] = ABCDE[0];
                 ABCDE[0] = temp;
	   }
	}    
}
//==========================================================
//APP_FUNCTION ??????,??????????
//inlen /  inbuf : ??buf??? / ??buf
//outlen / outbuf: ????buf??? / ??buf
//==========================================================
unsigned char APP_FUNCTION(unsigned char inlen,unsigned char *inbuf,unsigned char *outbuf)
{
    unsigned char i;
    unsigned char message_array[64];
    unsigned long  ABCDE[5];
	  unsigned long  M[16];

    for(i=0;i<64;i++)
    {
       message_array[i] = 0;
    }
   
    for(i=0;i<4;i++)
    {
       message_array[i+24] = inbuf[i];
    }
    for(i=4;i<8;i++)
    {
       message_array[i+56] = inbuf[i];
    }
   
    message_array[28] = 'R'; 
    message_array[29] = 'F';
    message_array[30] = 'I';
    message_array[31] = 'D'; 

    message_array[56] = 'T'; 
    message_array[57] = 'E';
    message_array[58] = 'S';
    message_array[59] = 'T';

    if(inlen>8)
    {
        if((inlen-8)<25)
        {
             for(i=0;i<(inlen-8);i++)
             {
                 message_array[i] = inbuf[i+8];
             }
        }
        else
        {
             for(i=0;i<24;i++)
             {
                 message_array[i] = inbuf[i+8];
             }
             for(i=0;i<(inlen-8-24);i++)
             {
                 message_array[i+32] = inbuf[i+8+24];
             }
        }
        
    }  

    for(i=0;i<16;i++)//8??32?
    {
	    M[i] = (unsigned long)message_array[i*4]<<24;
		  M[i] |= (unsigned long)message_array[i*4+1]<<16;
		  M[i] |= (unsigned long)message_array[i*4+2]<<8;
		  M[i] |= (unsigned long)message_array[i*4+3];
	  }

    SHA1ProcessMessageBlock(ABCDE,M);
    
    for(i=0;i<5;i++)//8??32?
    {
	    outbuf[i*4] = ABCDE[i]>>24;
		  outbuf[i*4+1] = ABCDE[i]>>16;
		  outbuf[i*4+2] = ABCDE[i]>>8;
		  outbuf[i*4+3] = ABCDE[i];
	  }
    return 1;
}

